import discord
from discord.ext import commands, tasks
from datetime import datetime, time, timedelta
import asyncio
import os
import json
import random
import asyncpg
from dotenv import load_dotenv
from flask import Flask
from threading import Thread
from elo_mvp_system import przetworz_mecz, ranking, profil, wczytaj_dane, zapisz_dane, PUNKTY_ELO, przewidywana_szansa
from collections import Counter
from discord.ui import View, Select, Button
from discord import SelectOption, Interaction, ButtonStyle



# Flask do keep-alive
app = Flask('')

@app.route('/')
def home():
    return "Bot dzia≈Ça :)"

def run():
    app.run(host='0.0.0.0', port=8080)

def keep_alive():
    t = Thread(target=run)
    t.start()

keep_alive()

# Intents i bot
load_dotenv()
TOKEN = os.getenv("DISCORD_TOKEN")
DB_URL = os.getenv("DATABASE_URL")

intents = discord.Intents.default()
intents.message_content = True
intents.members = True

bot = commands.Bot(command_prefix='!', intents=intents, help_command=None)

# Dane
MAX_SIGNUPS = 10
signups = []
waiting_list = []
log_file = 'signup_log.txt'
event_time = None
team1 = []
team2 = []
mvp_votes = {}
bot.mvp_mapping = {}
bot.mvp_vote_messages = []
bot.last_teams = {}
bot.zwyciezca = None
signup_ids = []
reminder_sent = False
panel_channel = None
panel_message = None
ranking_mode = False
enrollment_locked = False
signups_locked = False
signup_lock = asyncio.Lock()
player_nicknames = {}
db_pool = None
last_click_times = {}  # user_id: datetime


RANGA_EMOJI = {
    "Iron": "‚¨õ",
    "Bronze": "üü´",
    "Silver": "‚¨ú",
    "Gold": "üüß",
    "Platinum": "üü©",
    "Emerald": "üü¢",
    "Diamond": "üü¶",
    "Master": "üü™",
    "Grandmaster": "üü•",
    "Challenger": "üü®",
    "Unranked": "‚ö™"
}


wczytaj_dane()

# ---------- BAZA DANYCH ---------- #

db = None

async def connect_to_db():
    global db
    db = await asyncpg.connect(os.getenv("DATABASE_URL"))


db_pool = None

async def connect_lol_nick_pool():
    global db_pool
    try:
        db_pool = await asyncpg.create_pool(os.getenv("DATABASE_URL"))
        print("‚úÖ Po≈ÇƒÖczono z bazƒÖ nick√≥w LoL-a.")
    except Exception as e:
        print("‚ùå B≈ÇƒÖd przy ≈ÇƒÖczeniu z bazƒÖ nick√≥w:", e)




@bot.event
async def on_ready():
    await connect_to_db()
    await connect_lol_nick_pool()
    await create_tables()
    # refresh_panel.start()
    print(f'‚úÖ Zalogowano jako {bot.user.name}')
    check_event_time.start()


async def create_tables():
    async with db_pool.acquire() as conn:
        await conn.execute("""
            CREATE TABLE IF NOT EXISTS lol_nicknames (
                user_id BIGINT NOT NULL,
                nickname TEXT NOT NULL,
                PRIMARY KEY (user_id, nickname)
            );
        """)
    async with db_pool.acquire() as conn:
        await conn.execute('''
            CREATE TABLE IF NOT EXISTS ostrzezenia (
                user_id BIGINT PRIMARY KEY,
                liczba INTEGER NOT NULL DEFAULT 0
            );
        ''')


async def get_nicknames(user_id: int) -> list[tuple[str, str]]:
    if db_pool is None:
        print("‚ùå db_pool nie jest po≈ÇƒÖczone!")
        return []
    async with db_pool.acquire() as conn:
        rows = await conn.fetch("SELECT nickname, rank FROM lol_nicknames WHERE user_id = $1", user_id)
        return [(row["nickname"], row["rank"] or "Unranked") for row in rows]



async def add_nicknames(user_id: int, nicknames: list[str], rank: str = None):
    async with db_pool.acquire() as conn:
        for nick in nicknames:
            await conn.execute(
                """
                INSERT INTO lol_nicknames (user_id, nickname, rank)
                VALUES ($1, $2, $3)
                ON CONFLICT (user_id, nickname) DO NOTHING
                """,
                user_id, nick, rank
            )
            
async def update_rank(user_id: int, nickname: str, new_rank: str):
    async with db_pool.acquire() as conn:
        await conn.execute(
            """
            UPDATE lol_nicknames
            SET rank = $1
            WHERE user_id = $2 AND nickname = $3
            """,
            new_rank, user_id, nickname
        )



@tasks.loop(seconds=60)
async def check_event_time():
    global event_time, reminder_sent, tematyczne_event_time, tematyczne_reminder_sent

    now = datetime.now() + timedelta(hours=2)

    if panel_channel is None:
        return

    # G≈Ç√≥wna lista
    if event_time and not reminder_sent:
        diff = event_time - now
        if timedelta(minutes=14) < diff <= timedelta(minutes=15):
            reminder_sent = True
            if signups:
                mentions = " ".join(user.mention for user in signups)
                await panel_channel.send(f"‚è∞ **Przypomnienie!** Customy za 15 minut!\n{mentions}", delete_after=2400)
            else:
                await panel_channel.send("‚è∞ Customy za 15 minut, ale lista g≈Ç√≥wna jest pusta.", delete_after=2400)

    # Tematyczna lista
    if tematyczne_event_time and not tematyczne_reminder_sent:
        diff = tematyczne_event_time - now
        if timedelta(minutes=14) < diff <= timedelta(minutes=15):
            tematyczne_reminder_sent = True
            if tematyczne_gracze:
                mentions = " ".join(f"<@{uid}>" for uid in tematyczne_gracze)
                await panel_channel.send(f"‚è∞ **Tematyczne przypomnienie!** Start za 15 minut!\n{mentions}", delete_after=1200)
            else:
                await panel_channel.send("‚è∞ Tematyczne: Brak zapisanych graczy.", delete_after=1200)


async def create_tables():
    await db.execute('''
        CREATE TABLE IF NOT EXISTS gracze (
            nick TEXT PRIMARY KEY,
            elo INTEGER NOT NULL,
            zagrane INTEGER NOT NULL,
            wygrane INTEGER NOT NULL,
            przegrane INTEGER NOT NULL,
            mvp INTEGER NOT NULL
        )
    ''')
    print("‚úÖ Tabela gracze gotowa.")

async def aktualizuj_gracza(nick, elo, zagrane, wygrane, przegrane, mvp):
    await db.execute('''
        INSERT INTO gracze (nick, elo, zagrane, wygrane, przegrane, mvp)
        VALUES ($1, $2, $3, $4, $5, $6)
        ON CONFLICT (nick)
        DO UPDATE SET
            elo = EXCLUDED.elo,
            zagrane = EXCLUDED.zagrane,
            wygrane = EXCLUDED.wygrane,
            przegrane = EXCLUDED.przegrane,
            mvp = EXCLUDED.mvp
    ''', nick, elo, zagrane, wygrane, przegrane, mvp)

async def pobierz_gracza(nick):
    row = await db.fetchrow('SELECT * FROM gracze WHERE nick = $1', nick)
    if row:
        return dict(row)
    else:
        return None


# ---------- RANGI ---------- #

RANGI = [
    "Iron", "Bronze", "Silver", "Gold", "Platinum",
    "Emerald", "Diamond", "Master", "Grandmaster", "Challenger"
]

class RankingPanelView(View):
    def __init__(self):
        super().__init__(timeout=None)

    @discord.ui.button(label="Ustaw rangƒô", style=ButtonStyle.primary, custom_id="ustaw_range_button")
    async def ustaw_range(self, interaction: Interaction, button: Button):
        nicki = await get_nicknames(interaction.user.id)
        nicknames_only = [n for n, _ in nicki]

        if not nicknames_only:
            return await interaction.response.send_message("‚ùå Nie masz ≈ºadnych dodanych nick√≥w. U≈ºyj 'Dodaj nick'.", ephemeral=True, delete_after=60)

        view = UstawRangaDropdownView(interaction.user, nicknames_only)
        await interaction.response.send_message("üéØ Wybierz nick i przypisz mu rangƒô:", view=view, ephemeral=True, delete_after=60)

    @discord.ui.button(label="‚ûï Dodaj nick", style=ButtonStyle.secondary, custom_id="dodaj_nick_button")
    async def dodaj_nick(self, interaction: Interaction, button: Button):
        await interaction.response.send_message("üì• Podaj nick(i) z LoL-a. Mo≈ºesz dodaƒá wiele, oddzielajƒÖc przecinkami.", ephemeral=True, delete_after=60)

        def check(msg):
            return msg.author.id == interaction.user.id and msg.channel == interaction.channel

        try:
            msg = await bot.wait_for("message", timeout=60, check=check)
            content = msg.content.strip()
            nicknames = [n.strip() for n in content.split(",") if n.strip()]
            if not nicknames:
                return await interaction.followup.send("‚ùå Nie podano ≈ºadnych nick√≥w.", ephemeral=True, delete_after=60)

            await add_nicknames(interaction.user.id, nicknames)
            await interaction.followup.send(f"‚úÖ Dodano {len(nicknames)} nick(√≥w): {', '.join(nicknames)}", ephemeral=True, delete_after=60)
            await msg.delete()

        except asyncio.TimeoutError:
            await interaction.followup.send("‚è≥ Czas minƒÖ≈Ç. Spr√≥buj ponownie.", ephemeral=True, delete_after=60)

async def add_nicknames(user_id: int, nicknames: list[str], rank: str = None):
    async with db_pool.acquire() as conn:
        for nick in nicknames:
            await conn.execute(
                """
                INSERT INTO lol_nicknames (user_id, nickname, rank)
                VALUES ($1, $2, $3)
                ON CONFLICT DO NOTHING
                """,
                user_id, nick, rank
            )


        
class UstawRangaDropdownView(View):
    def __init__(self, user, nicki):
        super().__init__(timeout=60)
        self.user = user
        self.selected_nick = None

        self.nick_select = Select(
            placeholder="üîπ Wybierz sw√≥j nick",
            options=[SelectOption(label=n) for n in nicki],
            custom_id="nick_select"
        )
        self.nick_select.callback = self.select_nick
        self.add_item(self.nick_select)

        self.rank_select = Select(
            placeholder="üèÖ Wybierz rangƒô",
            options=[SelectOption(label=r) for r in RANGI],
            custom_id="rank_select"
        )
        self.rank_select.callback = self.select_rank
        self.add_item(self.rank_select)

    async def select_nick(self, interaction: Interaction):
        if interaction.user.id != self.user.id:
            return await interaction.response.send_message("‚õî To nie Tw√≥j panel.", ephemeral=True, delete_after=60)

        self.selected_nick = self.nick_select.values[0]
        await interaction.response.send_message(f"‚úÖ Wybrano nick: `{self.selected_nick}`", ephemeral=True, delete_after=60)

    async def select_rank(self, interaction: Interaction):
        if interaction.user.id != self.user.id:
            return await interaction.response.send_message("‚õî To nie Tw√≥j panel.", ephemeral=True, delete_after=60)

        if not self.selected_nick:
            return await interaction.response.send_message("‚ö†Ô∏è Najpierw wybierz nick!", ephemeral=True, delete_after=60)

        selected_rank = self.rank_select.values[0]
        await update_rank(interaction.user.id, self.selected_nick, selected_rank)
        await interaction.response.send_message(
            f"üèÖ Ustawiono rangƒô **{selected_rank}** dla `{self.selected_nick}`", ephemeral=True, delete_after=60
        )
        
async def update_rank(user_id: int, nickname: str, new_rank: str):
    async with db_pool.acquire() as conn:
        await conn.execute(
            "UPDATE lol_nicknames SET rank = $1 WHERE user_id = $2 AND nickname = $3",
            new_rank, user_id, nickname
        )

@bot.command(name="rangipanel")
@commands.has_permissions(administrator=True)
async def rangipanel(ctx):
    view = RankingPanelView()
    await ctx.send("üìå **Panel ustawiania rangi** ‚Äì kliknij przycisk, aby ustawiƒá rangƒô dla swoich nick√≥w:", view=view)


# ---------- INFO I OPIS ---------- #



@bot.command(name="info")
async def info(ctx):
    """Wy≈õwietla listƒô wszystkich dostƒôpnych komend i funkcji."""
    embed = discord.Embed(
        title="‚ÑπÔ∏è Informacje o bocie",
        description="Poni≈ºej znajdziesz listƒô dostƒôpnych komend oraz przycisk√≥w bota.",
        color=discord.Color.blue()
    )

    embed.add_field(
        name="üéÆ Komendy og√≥lne",
        value=(
            "`!info` ‚Äì pokazuje tƒô wiadomo≈õƒá\n"
            "`!ksante` ‚Äì easter egg üòÑ"
        ),
        inline=False
    )

    embed.add_field(
        name="üìã Panel g≈Ç√≥wny (`!panel`)",
        value=(
            "`!panel` ‚Äì wy≈õwietla panel zapis√≥w\n"
            "`!lista` ‚Äì pokazuje aktualnƒÖ listƒô graczy\n"
            "üìå Przycisk **Zapisz / Wypisz** ‚Äì do≈ÇƒÖczenie do gry\n"
            "üïí Przycisk **Ustaw czas** ‚Äì ustawia godzinƒô wydarzenia\n"
            "üßπ Przycisk **Wyczy≈õƒá listy** ‚Äì czy≈õci g≈Ç√≥wnƒÖ i rezerwowƒÖ\n"
            "üóëÔ∏è / ‚ûï / üì§ ‚Äì admin mo≈ºe zarzƒÖdzaƒá graczami\n"
            "üì¢ Ping ‚Äì powiadamia graczy"
        ),
        inline=False
    )

    embed.add_field(
        name="üé® Panel tematyczny (`!tematyczne`)",
        value=(
            "`!tematyczne` ‚Äì uruchamia panel zapis√≥w z wyborem r√≥l (top, jg, mid, adc, supp)\n"
            "`!tematyczne_test` ‚Äì dodaje testowych graczy do listy (admin)\n"
            "üìå Przycisk **Do≈ÇƒÖcz / Wypisz** ‚Äì z wyborem r√≥l\n"
            "üõ†Ô∏è **Ustaw czas** ‚Äì ustawia godzinƒô wydarzenia\n"
            "üì¢ **Pinguj graczy** ‚Äì powiadomienie dla zapisanych\n"
            "‚úèÔ∏è **Zmie≈Ñ nazwƒô serii** ‚Äì zmienia nazwƒô widocznƒÖ w embedzie\n"
            "‚ûï **Dodaj gracza** ‚Äì admin podaje @gracza i linie\n"
            "üóëÔ∏è **Usu≈Ñ gracza** ‚Äì admin usuwa wskazanego gracza\n"
            "üßπ **Wyczy≈õƒá listƒô** ‚Äì czy≈õci ca≈ÇƒÖ listƒô\n"
            "üé≤ **Losuj dru≈ºyny** ‚Äì dzieli zapisanych na 2 zespo≈Çy z pe≈ÇnƒÖ kompozycjƒÖ r√≥l"
        ),
        inline=False
    )

    embed.set_footer(text="Bot przygotowany z my≈õlƒÖ o customach League of Legends ‚ù§Ô∏è")

    await ctx.send(embed=embed)

@bot.command(name="opis")
async def opis(ctx):
    """Wy≈õwietla wersjƒô bota i jego przeznaczenie."""
    embed = discord.Embed(
        title="ü§ñ KonikBOT ‚Äì Wersja 5.3",
        description=(
            "KonikBOT stworzony do organizowania gier customowych w League of Legends.\n\n"
            "Umo≈ºliwia tworzenie zapis√≥w, organizowanie gier tematycznych z zachowaniem r√≥l.\n"
            "Panel tematyczny pozwala na wydarzenia z motywem serii skin√≥w\n"
        ),
        color=discord.Color.green()
    )

    embed.set_footer(text="Developed by BarowatyPL (geniusz, chuda maszyna, ostatni pod Targonem, pierwszy na midzie, nie d≈∫wiga bosko≈õci ‚Äî niesie jƒÖ na barkach)")
    await ctx.send(embed=embed)



@bot.command()
@commands.has_permissions(administrator=True)
async def regulamin(ctx):
    """Wy≈õwietla regulamin custom√≥w LoL"""
    try:
        await ctx.message.delete(delay=5)
    except discord.Forbidden:
        pass  # na wypadek braku uprawnie≈Ñ do kasowania

    regulamin_text = (
        "**üìú Regulamin Custom√≥w LoL**\n\n"
        "‚è∞ **Punktualno≈õƒá**\n"
        "Gracz, kt√≥ry nie pojawi siƒô na czas i nie poinformuje o swojej nieobecno≈õci przynajmniej 10 minut przed rozpoczƒôciem gry, ≈Çamie zasady.\n\n"
        "üö´ **Zapraszanie os√≥b trzecich**\n"
        "Nie wolno zapraszaƒá os√≥b spoza ustalonego sk≈Çadu bez wiedzy organizatora. Osoba, kt√≥ra to zrobi, zostaje usuniƒôta z rozgrywki.\n\n"
        "üß† **Zapomniany Smite? Gramy dalej**\n"
        "Nie przerywamy gry z powodu pomy≈Çek takich jak brak smite‚Äôa. Gramy dalej ‚Äì liczy siƒô zabawa, a nie perfekcja.\n\n"
        "‚ùå **Pomy≈Çki w pickach**\n"
        "Je≈õli kto≈õ wybierze niew≈Ça≈õciwƒÖ postaƒá, gra jest kontynuowana.\n"
        "_WyjƒÖtek: w ARAM 5v5 ka≈ºda dru≈ºyna mo≈ºe raz przerwaƒá grƒô z tego powodu._\n\n"
        "üîÅ **Ko≈Ñczysz grƒô = wypisz siƒô**\n"
        "Gracz ko≈ÑczƒÖcy udzia≈Ç w grach ma obowiƒÖzek wypisaƒá siƒô z listy. Aby zagraƒá ponownie, nale≈ºy zapisaƒá siƒô od nowa po przerwie.\n\n"
        "‚è≥ **Czekanie na osobƒô z ≈Çawki**\n"
        "Na osobƒô z ≈Çawki czekamy maksymalnie 5 minut. Czas mo≈ºe byƒá wyd≈Çu≈ºony do 10 minut tylko wtedy, gdy wszyscy gracze wyra≈ºƒÖ zgodƒô a osoba potwierdzi swoje szybkie przybycie.\n\n"
        "üßÆ **Dob√≥r graczy z ≈Çawki**\n"
        "Gracze z ≈Çawki sƒÖ wybierani na podstawie tego, kto pierwszy napisze na kanale, ≈ºe chce graƒá ‚Äì po otrzymanym pingu. Wcze≈õniejsza wiadomo≈õƒá nie ma znaczenia.\n"
        "_Nie liczy siƒô samo wej≈õcie na kana≈Ç g≈Çosowy ani reakcje na wiadomo≈õci._\n\n"
        "üö∑ **Przerwy tylko w nag≈Çych wypadkach**\n"
        "Przerwy sƒÖ dopuszczalne wy≈ÇƒÖcznie w sytuacjach wyjƒÖtkowych (np. awaria, pilna sprawa). Nie robimy przerw na toaletƒô, jedzenie czy inne mniej istotne potrzeby.\n\n"
        "*W przypadku niejasno≈õci decyzjƒô podejmujƒÖ administratorzy.*"
    )

    await ctx.send(regulamin_text, delete_after=1200)


# ---------- SYSTEM ZAPIS√ìW I WY≈öWIETLANIA ---------- #

event_time = None  # dodane globalnie

async def generate_embed_async():
    global signups_locked, event_time, ranking_mode, signups, waiting_list, db_pool

    embed = discord.Embed(title="Panel zapis√≥w", color=discord.Color.green())

    lock_status = "üîí **Zapisy na listƒô g≈Ç√≥wnƒÖ sƒÖ zatrzymane.**" if signups_locked else "‚úÖ **Zapisy na listƒô g≈Ç√≥wnƒÖ sƒÖ otwarte.**"

    if event_time:
        czas_wydarzenia = f"üïí **Czas wydarzenia:** {event_time.strftime('%H:%M')}"
    else:
        czas_wydarzenia = "üïí **Czas wydarzenia nie zosta≈Ç jeszcze ustawiony.**"

    ranking_info = "üèÜ **Rankingowa**" if ranking_mode else "üéÆ **Nierankingowa**"

    embed.description = f"{lock_status}\n{czas_wydarzenia}\n{ranking_info}"

    # Lista g≈Ç√≥wna
    if signups:
        signup_lines = []
        for user in signups:
            nicki_z_rangami = await get_nicknames(user.id)

            if nicki_z_rangami:
                formatted_nicks = []
                for nick, ranga in nicki_z_rangami:
                    formatted_nicks.append(f"`{nick}`")
                formatted_nicks_str = ", ".join(formatted_nicks)
                pierwsza_ranga = nicki_z_rangami[0][1]
                ranga_emoji = RANGA_EMOJI.get(pierwsza_ranga, RANGA_EMOJI["Unranked"])
            else:
                formatted_nicks_str = "*brak nicku*"
                ranga_emoji = RANGA_EMOJI["Unranked"]

            async with db_pool.acquire() as conn:
                result = await conn.fetchrow("SELECT liczba FROM ostrzezenia WHERE user_id = $1", user.id)
                liczba = result["liczba"] if result else 0
                status = "ban" if liczba >= 4 else f"{liczba}/3"

            signup_lines.append(f"{status} ‚Ä¢ {ranga_emoji} {user.mention} ‚Äì {formatted_nicks_str}")
        signup_str = "\n".join(signup_lines)
    else:
        signup_str = "Brak"

    # Lista rezerwowa
    if waiting_list:
        reserve_lines = []
        for user in waiting_list:
            nicki_z_rangami = await get_nicknames(user.id)

            if nicki_z_rangami:
                formatted_nicks = []
                for nick, ranga in nicki_z_rangami:
                    formatted_nicks.append(f"`{nick}`")
                formatted_nicks_str = ", ".join(formatted_nicks)
                pierwsza_ranga = nicki_z_rangami[0][1]
                ranga_emoji = RANGA_EMOJI.get(pierwsza_ranga, RANGA_EMOJI["Unranked"])
            else:
                formatted_nicks_str = "*brak nicku*"
                ranga_emoji = RANGA_EMOJI["Unranked"]

            async with db_pool.acquire() as conn:
                result = await conn.fetchrow("SELECT liczba FROM ostrzezenia WHERE user_id = $1", user.id)
                liczba = result["liczba"] if result else 0
                status = "ban" if liczba >= 4 else f"{liczba}/3"

            reserve_lines.append(f"{status} ‚Ä¢ {ranga_emoji} {user.mention} ‚Äì {formatted_nicks_str}")
        reserve_str = "\n".join(reserve_lines)
    else:
        reserve_str = "Brak"

    embed.add_field(name=f"Lista g≈Ç√≥wna ({len(signups)}/{MAX_SIGNUPS})", value=signup_str, inline=False)
    embed.add_field(name="Lista rezerwowa", value=reserve_str, inline=False)

    return embed





def generate_tematyczne_embed():
    embed = discord.Embed(title=f"Dzisiejsze skiny: {seria1_nazwa} vs {seria2_nazwa}", color=discord.Color.purple())

    if tematyczne_event_time:
        embed.description = f"üïí **Czas wydarzenia:** {tematyczne_event_time.strftime('%H:%M')}"
    else:
        embed.description = "üïí **Czas wydarzenia nie zosta≈Ç ustawiony.**"

    if not tematyczne_gracze:
        embed.add_field(name="Gracze", value="Brak zapisanych graczy.", inline=False)
    else:
        opis = "\n".join(
            f"{i+1}. <@{uid}> ‚Äì [{', '.join(data['linie'])}]"
            for i, (uid, data) in enumerate(tematyczne_gracze.items())
        )
        embed.add_field(name="Gracze", value=opis, inline=False)

    return embed




class SignupPanel(discord.ui.View):
    def __init__(self, *, timeout=None, message):
        super().__init__(timeout=timeout)
        self.message = message
        

    @discord.ui.button(label="Zapisz", style=discord.ButtonStyle.success)
    async def signup(self, interaction: discord.Interaction, button: discord.ui.Button):
        user = interaction.user
        now = datetime.utcnow()
        cooldown = 10  # sekundy
    
        if user.id in last_click_times and (now - last_click_times[user.id]).total_seconds() < cooldown:
            await interaction.response.send_message(
                f"‚è≥ Poczekaj {cooldown} sekund przed ponownym klikniƒôciem.",
                ephemeral=True
            )
            return
    
        last_click_times[user.id] = now
    
        async with signup_lock:
            # Sprawdzenie ostrze≈ºe≈Ñ
            async with db_pool.acquire() as conn:
                result = await conn.fetchrow("SELECT liczba FROM ostrzezenia WHERE user_id = $1", user.id)
                if result and result["liczba"] >= 4:
                    await interaction.response.send_message(
                        "üö´ Masz bana na customy. Skontaktuj siƒô z administracjƒÖ.",
                        ephemeral=True
                    )
                    return
    
            if user in signups or user in waiting_list:
                await interaction.response.send_message("‚ùó Jeste≈õ ju≈º zapisany.", ephemeral=True)
                return
    
            nicknames = await get_nicknames(user.id)
            if not nicknames:
                success = await self.ask_for_nickname(interaction, user)
                if not success:
                    return
                await self.update_message(interaction)
    
            if signups_locked:
                waiting_list.append(user)
                await log_to_discord(f"üë§ {user.mention} zapisa≈Ç siƒô na listƒô rezerwowƒÖ (g≈Ç√≥wna zablokowana).")
            else:
                if len(signups) < MAX_SIGNUPS:
                    signups.append(user)
                    await log_to_discord(f"üë§ {user.mention} zapisa≈Ç siƒô na listƒô g≈Ç√≥wnƒÖ.")
                else:
                    waiting_list.append(user)
                    await log_to_discord(f"üë§ {user.mention} zapisa≈Ç siƒô na listƒô rezerwowƒÖ (brak miejsca).")
    
            await self.update_message(interaction)



    @discord.ui.button(label="Wypisz", style=discord.ButtonStyle.danger)
    async def withdraw(self, interaction: discord.Interaction, button: discord.ui.Button):
        user = interaction.user
        now = datetime.utcnow()
        cooldown = 10  # sekundy
    
        if user.id in last_click_times and (now - last_click_times[user.id]).total_seconds() < cooldown:
            await interaction.response.send_message(
                f"‚è≥ Poczekaj {cooldown} sekund przed ponownym klikniƒôciem.",
                ephemeral=True
            )
            return
    
        last_click_times[user.id] = now
    
        if user in signups:
            signups.remove(user)
        elif user in waiting_list:
            waiting_list.remove(user)
        else:
            return
    
        await log_to_discord(f"üë§ {user.mention} wypisa≈Ç siƒô z listy.")
        await self.update_message(interaction)

    @discord.ui.button(label="Zapisz na rezerwƒô", style=discord.ButtonStyle.secondary, row=1)
    async def signup_reserve(self, interaction: discord.Interaction, button: discord.ui.Button):
        user = interaction.user
        now = datetime.utcnow()
        cooldown = 10
    
        if user.id in last_click_times and (now - last_click_times[user.id]).total_seconds() < cooldown:
            await interaction.response.send_message(f"‚è≥ Poczekaj {cooldown} sekund przed ponownym klikniƒôciem.", ephemeral=True)
            return
    
        last_click_times[user.id] = now
    
        async with signup_lock:
            async with db_pool.acquire() as conn:
                result = await conn.fetchrow("SELECT liczba FROM ostrzezenia WHERE user_id = $1", user.id)
                if result and result["liczba"] >= 4:
                    await interaction.response.send_message("üö´ Masz bana na customy. Skontaktuj siƒô z administracjƒÖ.", ephemeral=True)
                    return
    
            if any(u.id == user.id for u in signups + waiting_list):
                await interaction.response.send_message("‚ùó Ju≈º jeste≈õ zapisany na listƒô.", ephemeral=True)
                return
    
            nicknames = await get_nicknames(user.id)
            if not nicknames:
                success = await self.ask_for_nickname(interaction, user)
                if not success:
                    return
                await self.update_message(interaction)
    
            waiting_list.append(user)
            await log_to_discord(f"üë§ {user.mention} zapisa≈Ç siƒô bezpo≈õrednio na **listƒô rezerwowƒÖ** (przycisk).")
            await self.update_message(interaction)


    
    @discord.ui.button(label="Ustaw czas", style=discord.ButtonStyle.primary)
    async def set_time(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not interaction.user.guild_permissions.administrator:
            await interaction.response.send_message("Tylko administrator mo≈ºe ustawiƒá czas wydarzenia.", ephemeral=True, delete_after=10)
            return
        await interaction.response.send_message("Podaj godzinƒô wydarzenia w formacie `HH:MM`:", ephemeral=True, delete_after=10)
    
        def check(msg): return msg.author == interaction.user and msg.channel == interaction.channel
        try:
            msg = await bot.wait_for("message", timeout=60.0, check=check)
            hour, minute = map(int, msg.content.strip().split(":"))
            global event_time, reminder_sent
            now = datetime.now()
            event_time = now.replace(hour=hour, minute=minute, second=0, microsecond=0)
            if event_time < now:
                event_time += timedelta(days=1)
            reminder_sent = False
            await msg.delete()
            await self.update_message(interaction)
            await log_to_discord(f"üë§ {interaction.user.mention} ustawi≈Ç czas wydarzenia na {event_time.strftime('%H:%M')}.")
        except asyncio.TimeoutError:
            await interaction.followup.send("Czas na odpowied≈∫ minƒÖ≈Ç.", ephemeral=True, delete_after=10)
        except ValueError:
            await interaction.followup.send("Niepoprawny format godziny.", ephemeral=True, delete_after=10)
    
    @discord.ui.button(label="üóëÔ∏è Usu≈Ñ gracza", style=discord.ButtonStyle.danger, row=1)
    async def remove_user(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not interaction.user.guild_permissions.administrator:
            return
    
        await interaction.response.send_message("Podaj @u≈ºytkownika do usuniƒôcia:", ephemeral=True)
        prompt = await interaction.original_response()
    
        def check(msg):
            return msg.author == interaction.user and msg.channel == interaction.channel
    
        try:
            msg = await bot.wait_for("message", timeout=30.0, check=check)
            if not msg.mentions:
                await prompt.delete()
                await msg.delete()
                return
    
            user = msg.mentions[0]
            removed_from = None
    
            if any(u.id == user.id for u in signups):
                signups[:] = [u for u in signups if u.id != user.id]
                removed_from = "g≈Ç√≥wnej"
            elif any(u.id == user.id for u in waiting_list):
                waiting_list[:] = [u for u in waiting_list if u.id != user.id]
                removed_from = "rezerwowej"
    
            if removed_from:
                await log_to_discord(f"üë§ {interaction.user.mention} usunƒÖ≈Ç {user.mention} z listy {removed_from}.")
                await self.update_message(interaction)
    
            await prompt.delete()
            await msg.delete()
    
        except asyncio.TimeoutError:
            await prompt.delete()


    @discord.ui.button(label="‚ûï Dodaj gracza", style=discord.ButtonStyle.success, row=1)
    async def add_user(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not interaction.user.guild_permissions.administrator:
            return
    
        await interaction.response.send_message("Podaj @u≈ºytkownika do dodania na listƒô g≈Ç√≥wnƒÖ:", ephemeral=True)
        prompt = await interaction.original_response()
    
        def check(msg):
            return msg.author == interaction.user and msg.channel == interaction.channel
    
        try:
            msg = await bot.wait_for("message", timeout=30.0, check=check)
            if not msg.mentions:
                await prompt.delete()
                await msg.delete()
                return
    
            user = msg.mentions[0]
            if any(u.id == user.id for u in signups + waiting_list):
                await prompt.delete()
                await msg.delete()
                return
    
            nicknames = await get_nicknames(user.id)
            if not nicknames:
                success = await self.ask_for_nickname_admin(interaction.channel, user)
                if not success:
                    await prompt.delete()
                    await msg.delete()
                    return
    
            if len(signups) < MAX_SIGNUPS:
                signups.append(user)
                await log_to_discord(f"üë§ {interaction.user.mention} doda≈Ç {user.mention} do listy g≈Ç√≥wnej.")
                await self.update_message(interaction)
            else:
                await interaction.followup.send("‚ùó Lista g≈Ç√≥wna jest pe≈Çna.", ephemeral=True)
    
            await prompt.delete()
            await msg.delete()
    
        except asyncio.TimeoutError:
            await prompt.delete()

    @discord.ui.button(label="üì§ Przenie≈õ z rezerwy", style=discord.ButtonStyle.success, row=1)
    async def move_user(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not interaction.user.guild_permissions.administrator:
            return
        
        if len(signups) >= MAX_SIGNUPS:
            await interaction.response.send_message("‚ùó Lista g≈Ç√≥wna jest pe≈Çna.", ephemeral=True)
            return
        
        await interaction.response.send_message("Podaj @u≈ºytkownika do przeniesienia z rezerwy:", ephemeral=True)
        prompt = await interaction.original_response()
        
        def check(msg):
            return msg.author == interaction.user and msg.channel == interaction.channel
        
        try:
            msg = await bot.wait_for("message", timeout=30.0, check=check)
            if not msg.mentions:
                await prompt.delete()
                await msg.delete()
                return
        
            user = msg.mentions[0]
            if any(u.id == user.id for u in waiting_list):
                waiting_list[:] = [u for u in waiting_list if u.id != user.id]
                signups.append(user)
                await log_to_discord(f"üë§ {interaction.user.mention} przeni√≥s≈Ç {user.mention} z rezerwy do listy g≈Ç√≥wnej.")
                await self.update_message(interaction)
        
            await prompt.delete()
            await msg.delete()
        
        except asyncio.TimeoutError:
            await prompt.delete()
    


    
    @discord.ui.button(label="ü™É Wyczy≈õƒá listy", style=discord.ButtonStyle.danger, row=2)
    async def clear_lists(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not interaction.user.guild_permissions.administrator:
            return
    
        signups.clear()
        waiting_list.clear()
    
        global event_time, reminder_sent
        event_time = None
        reminder_sent = False
    
        await self.update_message(interaction, log_click=True)
        await log_to_discord(f"üë§ {interaction.user.mention} wyczy≈õci≈Ç listy i usunƒÖ≈Ç godzinƒô wydarzenia.")
    
    
    @discord.ui.button(label="üì¢ Ping lista g≈Ç√≥wna", style=discord.ButtonStyle.primary, row=2)
    async def ping_main(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not interaction.user.guild_permissions.administrator:
            return
        if not signups:
            return
    
        mentions = " ".join(user.mention for user in signups)
        await interaction.channel.send(f"üì¢ Lista g≈Ç√≥wna zosta≈Ça pingniƒôta przez {interaction.user.mention}:\n{mentions}")
        await log_to_discord(f"üë§ {interaction.user.mention} pingnƒÖ≈Ç listƒô g≈Ç√≥wnƒÖ.")


    @discord.ui.button(label="üì¢ Ping rezerwa", style=discord.ButtonStyle.secondary, row=2)
    async def ping_reserve(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not interaction.user.guild_permissions.administrator:
            return
        if not waiting_list:
            await interaction.response.send_message("‚ùó Lista rezerwowa jest pusta.", ephemeral=True)
            return
    
        channel_id = 1371869603227242537
        target_channel = interaction.guild.get_channel(channel_id)
    
        if target_channel:
            mentions = " ".join(user.mention for user in waiting_list)
            await target_channel.send(f"üì¢ Lista rezerwowa zosta≈Ça pingniƒôta przez {interaction.user.mention}:\n{mentions}")
            await log_to_discord(f"üë§ {interaction.user.mention} pingnƒÖ≈Ç listƒô rezerwowƒÖ w <#{channel_id}>.")


    
    @discord.ui.button(label="üéÆ Zmie≈Ñ tryb", style=discord.ButtonStyle.primary, row=2)
    async def toggle_ranking(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not interaction.user.guild_permissions.administrator:
            return
    
        global ranking_mode
        ranking_mode = not ranking_mode
        await self.update_message(interaction, log_click=True)
        await log_to_discord(f"üë§ {interaction.user.mention} zmieni≈Ç tryb gry na {'üèÜ Rankingowa' if ranking_mode else 'üéÆ Nierankingowa'}.")


    @discord.ui.button(label="üîí Zatrzymaj zapisy", style=discord.ButtonStyle.primary, row=3)
    async def toggle_lock(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not interaction.user.guild_permissions.administrator:
            return
    
        global signups_locked
        signups_locked = not signups_locked
    
        button.label = "‚úÖ Wzn√≥w zapisy" if signups_locked else "üîí Zatrzymaj zapisy"
        await self.update_message(interaction)
        await log_to_discord(f"üë§ {interaction.user.mention} {'zatrzyma≈Ç' if signups_locked else 'wznowi≈Ç'} zapisy na listƒô g≈Ç√≥wnƒÖ.")


    async def update_message(self, interaction: discord.Interaction, log_click: bool = False):
        embed = await generate_embed_async()
    
        try:
            await self.message.edit(embed=embed, view=self)
        except discord.HTTPException:
            pass
    
        if interaction.response.is_done():
            try:
                await interaction.followup.send("‚úÖ Panel zaktualizowany.", ephemeral=True, delete_after=3)
            except:
                pass
        else:
            try:
                await interaction.response.defer()
            except discord.InteractionResponded:
                pass
    
        if log_click:
            await log_to_discord(f"üëÜ {interaction.user.mention} zmieni≈Ç stan zapis√≥w.")



    async def ask_for_nickname(self, interaction: discord.Interaction, user: discord.User) -> bool:
        await interaction.response.send_message(
            "üîπ Podaj sw√≥j nick z LoL-a (np. `Nick#EUW`). Mo≈ºesz podaƒá kilka, oddzielajƒÖc przecinkami.",
            ephemeral=True
        )
    
        def check(msg): return msg.author.id == user.id and msg.channel == interaction.channel
    
        try:
            msg = await bot.wait_for("message", timeout=60.0, check=check)
            nick_input = msg.content.strip()
            nicknames = [n.strip() for n in nick_input.split(",") if n.strip()]
            await msg.delete()
    
            if not nicknames:
                fail = await interaction.followup.send("‚ùå Nie podano ≈ºadnego nicku. Anulowano zapis.", ephemeral=True)
                await asyncio.sleep(5)
                await fail.delete()
                return False
    
            await add_nicknames(user.id, nicknames)
            success = await interaction.followup.send("‚úÖ Nick(i) zapisane.", ephemeral=True)
            await asyncio.sleep(5)
            await success.delete()
            return True
    
        except asyncio.TimeoutError:
            timeout = await interaction.followup.send("‚è≥ Czas minƒÖ≈Ç. Nie podano nicku.", ephemeral=True)
            await asyncio.sleep(5)
            await timeout.delete()
            return False
    
    async def ask_for_nickname_admin(self, channel, user: discord.User) -> bool:
        try:
            prompt = await channel.send(
                f"üîπ Podaj nick(i) LoL-a dla {user.mention} (oddziel przecinkami):"
            )

            def check(msg):
                return msg.author.guild_permissions.administrator and msg.channel == channel

            msg = await bot.wait_for("message", timeout=60.0, check=check)
            nick_input = msg.content.strip()
            nicknames = [n.strip() for n in nick_input.split(",") if n.strip()]

            if not nicknames:
                await msg.delete()
                fail_msg = await channel.send("‚ùå Nie podano ≈ºadnego nicku. Anulowano.")
                await asyncio.sleep(5)
                await fail_msg.delete()
                await prompt.delete()
                return False

            await add_nicknames(user.id, nicknames)
            await msg.delete()
            confirm = await channel.send(f"‚úÖ Dodano nick(i) dla {user.mention}.")
            await asyncio.sleep(5)
            await confirm.delete()
            await prompt.delete()
            return True

        except asyncio.TimeoutError:
            timeout_msg = await channel.send("‚è≥ Czas minƒÖ≈Ç. Nie podano nicku.")
            await asyncio.sleep(5)
            await timeout_msg.delete()
            await prompt.delete()
            return False

        except Exception as e:
            error_msg = await channel.send(f"‚ö†Ô∏è WystƒÖpi≈Ç b≈ÇƒÖd: {e}")
            await asyncio.sleep(5)
            await error_msg.delete()
            return False




@bot.command()
@commands.has_permissions(administrator=True)
async def panel(ctx):
    global panel_channel, panel_message
    panel_channel = ctx.channel
    embed = await generate_embed_async()
    view = SignupPanel(message=None)
    panel_message = await ctx.send(embed=embed, view=view)
    view.message = panel_message


             

@bot.command(name="lista")
@commands.has_permissions(administrator=True)
async def lista(ctx):
    """Wy≈õwietla listƒô zapisanych bez przycisk√≥w (tylko dla admina)."""
    embed = await generate_embed_async()
    await ctx.send(embed=embed)

# ---------- KOMENDY DO GIER RANKINGOWYCH ---------- #

@bot.command(name="profil")
async def profil(ctx, member: discord.Member = None):
    """Pokazuje profil gracza."""
    if member is None:
        member = ctx.author

    gracz = await pobierz_gracza(str(member))

    if not gracz:
        await ctx.send(f"‚ùå {member.mention} nie ma jeszcze profilu w rankingu.")
        return

    embed = discord.Embed(title=f"Profil gracza {member.name}", color=discord.Color.blue())
    embed.add_field(name="ELO", value=gracz["elo"], inline=True)
    embed.add_field(name="Zagrane mecze", value=gracz["zagrane"], inline=True)
    embed.add_field(name="Wygrane", value=gracz["wygrane"], inline=True)
    embed.add_field(name="Przegrane", value=gracz["przegrane"], inline=True)
    embed.add_field(name="MVP", value=gracz["mvp"], inline=True)

    await ctx.send(embed=embed)

@bot.command(name="ranking")
async def ranking(ctx, top: int = 10):
    """Pokazuje ranking ELO (domy≈õlnie top 10)."""
    rows = await db.fetch('SELECT * FROM gracze ORDER BY elo DESC LIMIT $1', top)

    if not rows:
        await ctx.send("‚ùå Brak graczy w rankingu.")
        return

    description = ""
    for i, row in enumerate(rows, start=1):
        description += f"**{i}.** {row['nick']} - {row['elo']} ELO\n"

    embed = discord.Embed(title=f"üèÜ Top {top} Graczy", description=description, color=discord.Color.gold())
    await ctx.send(embed=embed)

# ---------- TEMATYCZNE GRANIE ---------- #

import discord
from discord.ext import commands
import asyncio
import random
from datetime import datetime, timedelta

seria1_nazwa = "Seria 1"
seria2_nazwa = "Seria 2"
tematyczne_gracze_main = {}
tematyczne_gracze_rezerwowi = {}
tematyczne_event_time = None
tematyczne_reminder_sent = False

class TematycznePanel(discord.ui.View):
    def __init__(self, *, message, timeout=None):
        super().__init__(timeout=timeout)
        self.message = message

    @discord.ui.button(label="‚úÖ Do≈ÇƒÖcz", style=discord.ButtonStyle.success)
    async def join(self, interaction: discord.Interaction, button: discord.ui.Button):
        uid = interaction.user.id
        if uid in tematyczne_gracze_main or uid in tematyczne_gracze_rezerwowi:
            return await interaction.response.send_message("‚úÖ Ju≈º jeste≈õ zapisany.", ephemeral=True)

        if len(tematyczne_gracze_main) < 10:
            tematyczne_gracze_main[uid] = interaction.user
            msg = "‚úÖ Zapisano na g≈Ç√≥wnƒÖ listƒô!"
        else:
            tematyczne_gracze_rezerwowi[uid] = interaction.user
            msg = "‚ÑπÔ∏è G≈Ç√≥wna lista pe≈Çna. Zapisano na listƒô rezerwowƒÖ."

        await self.update_message()
        await interaction.response.send_message(msg, ephemeral=True)
    
    
    @discord.ui.button(label="‚ùå Wypisz", style=discord.ButtonStyle.danger)
    async def leave(self, interaction: discord.Interaction, button: discord.ui.Button):
        uid = interaction.user.id
        removed = False
        if uid in tematyczne_gracze_main:
            del tematyczne_gracze_main[uid]
            removed = True
        if uid in tematyczne_gracze_rezerwowi:
            del tematyczne_gracze_rezerwowi[uid]
            removed = True
        if removed:
            await self.update_message()
            await interaction.response.send_message("üëã Zosta≈Çe≈õ wypisany.", ephemeral=True)
        else:
            await interaction.response.send_message("‚ùå Nie by≈Çe≈õ zapisany.", ephemeral=True)


    @discord.ui.button(label="üìù Zapisz siƒô na rezerwƒô", style=discord.ButtonStyle.secondary)
    async def join_reserve(self, interaction: discord.Interaction, button: discord.ui.Button):
        uid = interaction.user.id
        if uid in tematyczne_gracze_main:
            return await interaction.response.send_message("‚úÖ Ju≈º jeste≈õ na g≈Ç√≥wnej li≈õcie!", ephemeral=True)
        if uid in tematyczne_gracze_rezerwowi:
            return await interaction.response.send_message("‚úÖ Ju≈º jeste≈õ na li≈õcie rezerwowej!", ephemeral=True)
    
        tematyczne_gracze_rezerwowi[uid] = interaction.user
        await self.update_message()
        await interaction.response.send_message("üìù Dodano Ciƒô na listƒô rezerwowƒÖ.", ephemeral=True)

    
    @discord.ui.button(label="üõ†Ô∏è Ustaw czas", style=discord.ButtonStyle.primary)
    async def set_time(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not interaction.user.guild_permissions.administrator:
            return await interaction.response.send_message("Tylko administrator mo≈ºe ustawiƒá czas.", ephemeral=True)

        await interaction.response.send_message("üïí Podaj godzinƒô wydarzenia w formacie `HH:MM`:", ephemeral=True)

        def check(m): return m.author == interaction.user and m.channel == interaction.channel
        try:
            msg = await bot.wait_for("message", timeout=60.0, check=check)
            hour, minute = map(int, msg.content.strip().split(":"))
            now = datetime.now()
            global tematyczne_event_time
            tematyczne_event_time = now.replace(hour=hour, minute=minute, second=0, microsecond=0)
            await msg.delete()
            await self.update_message()
            await interaction.followup.send(f"‚úÖ Czas ustawiony na {tematyczne_event_time.strftime('%H:%M')}", ephemeral=True)
        except:
            await interaction.followup.send("‚ùå B≈ÇƒÖd formatu. Spr√≥buj `HH:MM`.", ephemeral=True)

    @discord.ui.button(label="üì• Promuj z rezerwy", style=discord.ButtonStyle.secondary)
    async def promote(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not interaction.user.guild_permissions.administrator:
            return await interaction.response.send_message("Tylko administrator mo≈ºe przenosiƒá z rezerwy.", ephemeral=True)
    
        if len(tematyczne_gracze_main) >= 10:
            return await interaction.response.send_message("‚ùå G≈Ç√≥wna lista ju≈º pe≈Çna.", ephemeral=True)
    
        await interaction.response.send_message("üîé Wpisz @u≈ºytkownika do przeniesienia z rezerwy:", ephemeral=True)
    
        def check(m):
            return m.author == interaction.user and m.channel == interaction.channel
    
        try:
            msg = await bot.wait_for("message", timeout=30.0, check=check)
            mentioned = msg.mentions[0] if msg.mentions else None
    
            if not mentioned or mentioned.id not in tematyczne_gracze_rezerwowi:
                return await interaction.followup.send("‚ùå U≈ºytkownik nie jest na li≈õcie rezerwowej.", ephemeral=True)
    
            del tematyczne_gracze_rezerwowi[mentioned.id]
            tematyczne_gracze_main[mentioned.id] = mentioned
            await msg.delete()
            await self.update_message()
            await interaction.followup.send(f"üì§ Przeniesiono {mentioned.mention} do g≈Ç√≥wnej listy.", ephemeral=True)
    
        except asyncio.TimeoutError:
            await interaction.followup.send("‚è∞ Czas minƒÖ≈Ç. Nie wybrano gracza.", ephemeral=True)



    @discord.ui.button(label="üì¢ Pinguj graczy", style=discord.ButtonStyle.secondary)
    async def ping(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not interaction.user.guild_permissions.administrator:
            return await interaction.response.send_message("Tylko administrator mo≈ºe pingowaƒá.", ephemeral=True)
        if not tematyczne_gracze:
            return await interaction.response.send_message("‚ùå Brak zapisanych graczy.", ephemeral=True)
        mentions = " ".join(f"<@{uid}>" for uid in tematyczne_gracze)
        await interaction.response.send_message(f"üì¢ Ping: {mentions}", delete_after=300)

    @discord.ui.button(label="‚úèÔ∏è Zmie≈Ñ nazwƒô serii", style=discord.ButtonStyle.primary)
    async def rename(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not interaction.user.guild_permissions.administrator:
            return await interaction.response.send_message("Tylko administrator mo≈ºe zmieniƒá nazwy.", ephemeral=True)
    
        await interaction.response.send_message("‚úèÔ∏è Podaj nowƒÖ nazwƒô serii 1:", ephemeral=True)
        def check(m): return m.author == interaction.user and m.channel == interaction.channel
        try:
            msg1 = await bot.wait_for("message", timeout=30.0, check=check)
            global seria1_nazwa
            seria1_nazwa = msg1.content.strip()
            await interaction.followup.send("‚úèÔ∏è Podaj nowƒÖ nazwƒô serii 2:", ephemeral=True)
            msg2 = await bot.wait_for("message", timeout=30.0, check=check)
            global seria2_nazwa
            seria2_nazwa = msg2.content.strip()
            await msg1.delete()
            await msg2.delete()
            await self.update_message()
            await interaction.followup.send(f"‚úÖ Ustawiono: **{seria1_nazwa}** vs **{seria2_nazwa}**", ephemeral=True)
        except asyncio.TimeoutError:
            await interaction.followup.send("‚è∞ Czas minƒÖ≈Ç. Nie zmieniono.", ephemeral=True, delete_after=15)

    @discord.ui.button(label="üßπ Wyczy≈õƒá panel", style=discord.ButtonStyle.danger)
    async def clear_panel(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not interaction.user.guild_permissions.administrator:
            return await interaction.response.send_message("Tylko administrator mo≈ºe czy≈õciƒá panel.", ephemeral=True)
    
        tematyczne_gracze_main.clear()
        tematyczne_gracze_rezerwowi.clear()
        global tematyczne_event_time, tematyczne_reminder_sent
        tematyczne_event_time = None
        tematyczne_reminder_sent = False
    
        await self.update_message()
        await interaction.response.send_message("üßπ Panel zosta≈Ç wyczyszczony.", ephemeral=True)


    @discord.ui.button(label="üé≤ Losuj dru≈ºyny", style=discord.ButtonStyle.success)
    async def roll_teams(self, interaction: discord.Interaction, button: discord.ui.Button):
        if not interaction.user.guild_permissions.administrator:
            return await interaction.response.send_message("Tylko administrator mo≈ºe losowaƒá dru≈ºyny.", ephemeral=True)
    
        gracze = list(tematyczne_gracze.values())
        if len(gracze) < 10:
            return await interaction.response.send_message("‚ùå Potrzeba co najmniej 10 graczy do losowania.", ephemeral=True)
    
        random.shuffle(gracze)
        team1 = gracze[:5]
        team2 = gracze[5:10]
    
        def team_str(team):
            return "\n".join(f"‚Ä¢ {g['user'].mention}" for g in team)
    
        embed = discord.Embed(title=f"üéÆ {seria1_nazwa} vs {seria2_nazwa}", color=discord.Color.orange())
        embed.add_field(name=f"Dru≈ºyna 1 ({seria1_nazwa})", value=team_str(team1), inline=True)
        embed.add_field(name=f"Dru≈ºyna 2 ({seria2_nazwa})", value=team_str(team2), inline=True)
    
        await interaction.response.send_message(embed=embed, ephemeral=False, delete_after=600)


    async def update_message(self):
        embed = generate_tematyczne_embed()
        await self.message.edit(embed=embed, view=self)

@bot.command()
async def tematyczne(ctx):
    global panel_channel                
    panel_channel = ctx.channel         
    embed = generate_tematyczne_embed()
    msg = await ctx.send(embed=embed)
    view = TematycznePanel(message=msg)
    await msg.edit(view=view)

def generate_tematyczne_embed():
    embed = discord.Embed(title=f"üéÆ {seria1_nazwa} vs {seria2_nazwa}", color=discord.Color.blue())
    embed.description = "Kliknij ‚ÄûDo≈ÇƒÖcz‚Äù, aby zapisaƒá siƒô na event."

    if tematyczne_event_time:
        embed.add_field(name="üïí Godzina wydarzenia", value=tematyczne_event_time.strftime("%H:%M"), inline=False)

    if tematyczne_gracze_main:
        value = "\n".join(f"{i+1}. {user.mention}" for i, user in enumerate(tematyczne_gracze_main.values()))
        embed.add_field(name="‚úÖ G≈Ç√≥wna lista", value=value, inline=False)
    else:
        embed.add_field(name="‚úÖ G≈Ç√≥wna lista", value="Brak zapisanych graczy.", inline=False)

    if tematyczne_gracze_rezerwowi:
        value = "\n".join(f"{i+1}. {user.mention}" for i, user in enumerate(tematyczne_gracze_rezerwowi.values()))
        embed.add_field(name="üìã Rezerwa", value=value, inline=False)

    return embed




@bot.command(name="tematyczne_test")
@commands.has_permissions(administrator=True)
async def tematyczne_test(ctx):
    from types import SimpleNamespace

    test_gracze = [
        ("Gracz 1 (adc, top)", ["adc", "top"]),
        ("Gracz 2 (jg, mid)", ["jg", "mid"]),
        ("Gracz 3 (supp)", ["supp"]),
        ("Gracz 4 (mid)", ["mid"]),
        ("Gracz 5 (adc)", ["adc"]),
        ("Gracz 6 (jg)", ["jg"]),
        ("Gracz 7 (top)", ["top"]),
        ("Gracz 8 (supp)", ["supp"]),
        ("Gracz 9 (mid)", ["mid"]),
        ("Gracz 10 (top, jg)", ["top", "jg"]),
    ]

    base_id = 900000000000000000
    for i, (name, roles) in enumerate(test_gracze):
        mock_user = SimpleNamespace(
            id=base_id + i,
            mention=f"<@{base_id + i}>",
            name=name
        )
        tematyczne_gracze[mock_user.id] = {
            "user": mock_user,
            "linie_seria1": roles,
            "linie_seria2": roles
        }

    await ctx.send("‚úÖ Dodano 10 testowych graczy z rolami.", delete_after=10)


# ---------- KOMENDY DO NICK√ìW ---------- #

@bot.command(help="Dodaje nick(i) LoL do u≈ºytkownika. Mo≈ºna podaƒá wiele, oddzielajƒÖc przecinkami.\nPrzyk≈Çad: !dodajnick @nick_dc nick#EUNE, Nick2#EUNE")
@commands.has_permissions(administrator=True)
async def dodajnick(ctx, member: discord.Member = None, *, nicknames: str = None):
    await ctx.message.delete(delay=5)

    if not member or not nicknames:
        await ctx.send("üìå U≈ºycie: `!dodajnick @u≈ºytkownik Nick#EUW, Smurf#EUNE`", delete_after=10)
        return

    nickname_list = [n.strip() for n in nicknames.split(",") if n.strip()]
    if not nickname_list:
        await ctx.send("‚ùå Nie podano ≈ºadnego nicku.", delete_after=10)
        return

    await add_nicknames(member.id, nickname_list)
    await ctx.send(f"‚úÖ Dodano {len(nickname_list)} nick(√≥w) dla {member.mention}.", delete_after=10)



@bot.command(help="Usuwa nick LoL gracza.\nPrzyk≈Çad: !usunnick @nick_dc nick#EUNE")
@commands.has_permissions(administrator=True)
async def usunnick(ctx, member: discord.Member = None, *, nickname: str = None):
    await ctx.message.delete(delay=5)

    if not member or not nickname:
        await ctx.send("üìå U≈ºycie: `!usunnick @u≈ºytkownik Nick#EUW`", delete_after=10)
        return

    async with db_pool.acquire() as conn:
        result = await conn.execute(
            "DELETE FROM lol_nicknames WHERE user_id = $1 AND nickname = $2",
            member.id, nickname
        )
        if result.endswith("0"):
            await ctx.send(f"‚ùå Nick `{nickname}` nie zosta≈Ç znaleziony u {member.mention}.", delete_after=10)
        else:
            await ctx.send(f"üèÄ Nick `{nickname}` zosta≈Ç usuniƒôty dla {member.mention}.", delete_after=10)


@bot.command(help="Wy≈õwietla zapisane nicki gracza. Je≈õli nie podasz gracza, poka≈ºe Twoje.\nPrzyk≈Çad: !nicki @nick_dc")
async def nicki(ctx, member: discord.Member = None):
    await ctx.message.delete(delay=5)

    target = member or ctx.author
    nicknames = await get_nicknames(target.id)

    if not nicknames:
        await ctx.send(f"üîé {target.mention} nie ma zapisanych ≈ºadnych nick√≥w.", delete_after=10)
    else:
        formatted = "\n".join(f"`{nick}`" for nick in nicknames)
        await ctx.send(f"üìã Nicki zapisane dla {target.mention}:\n{formatted}", delete_after=10)







# ---------- KOMENDY DLA BEKI ---------- #

@bot.command(name="ksante")
async def ksante(ctx):
    tekst = ("K'Santeüë§ 4,700 HP üí™ 329 Armor ü§∑‚Äç‚ôÇÔ∏è 201 MR üí¶ Unstoppable üö´ "
             "A Shield üõ° Goes over walls üß± Has Airborne üå™ "
             "Cooldown is only ‚òù second too üïê It costs 15 Mana üßô‚Äç‚ôÇÔ∏è")
    
    await ctx.send(tekst, delete_after=300)

@bot.command(name="najlepszy")
async def info(ctx):
    """Wy≈õwietla informacje o bocie lub wydarzeniu."""
    tekst = ("Jestem Kurwa ≈õwietny, jestem najlepszy, jestem Bogiem tej gry!!!")
    await ctx.send(tekst, delete_after=300)

@bot.command(name="lulu")
async def info(ctx):
    """Wy≈õwietla informacje o bocie lub wydarzeniu."""
    tekst = ("JEBANA DZIWKA Z KAPELUSZEM!!!")
    await ctx.send(tekst, delete_after=300)

@bot.command(name="daj")
async def info(ctx):
    """Wy≈õwietla informacje o bocie lub wydarzeniu."""
    tekst = ("DAJCIE MI GO!!!")
    await ctx.send(tekst, delete_after=300)


# ---------- LOGI ---------- #

async def log_to_discord(message: str):
    log_channel_id = 1366403342695141446
    channel = bot.get_channel(log_channel_id)
    if channel:
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M")
        await channel.send(f"[{timestamp}] {message}")

@bot.command(name="logi")
@commands.has_permissions(administrator=True)
async def logi(ctx, liczba: int = 10):
    """Pokazuje ostatnie X log√≥w z kana≈Çu log√≥w (domy≈õlnie 10)."""
    log_channel_id = 1366403342695141446
    channel = bot.get_channel(log_channel_id)

    if not channel:
        await ctx.send("‚ùå Nie mogƒô znale≈∫ƒá kana≈Çu log√≥w.")
        return

    messages = [msg async for msg in channel.history(limit=liczba)]
    messages.reverse()

    formatted = "\n".join(msg.content for msg in messages)
    if not formatted:
        formatted = "Brak log√≥w do wy≈õwietlenia."

    await ctx.send(f"üìÑ **Ostatnie {liczba} log√≥w:**\n```{formatted}```")


# ---------- INNE ---------- #

@tasks.loop(minutes=5)
async def refresh_panel():
    if panel_channel:
        try:
            embed = await generate_embed_async()
            message = await panel_channel.send(embed=embed)
            view = SignupPanel(message=message)
            await message.edit(view=view)
        except Exception as e:
            print(f"B≈ÇƒÖd podczas od≈õwie≈ºania panelu: {e}")

async def odswiez_panel():
    global panel_message
    if panel_message:
        try:
            embed = await generate_embed_async()
            view = SignupPanel(message=panel_message)
            await panel_message.edit(embed=embed, view=view)
        except Exception as e:
            print(f"‚ùå B≈ÇƒÖd przy od≈õwie≈ºaniu panelu: {e}")



@bot.command(name="bancustom")
@commands.has_permissions(administrator=True)
async def bancustom(ctx, member: discord.Member):
    try:
        await ctx.message.delete(delay=5)
    except discord.Forbidden:
        pass

    async with db_pool.acquire() as conn:
        result = await conn.fetchrow("SELECT liczba FROM ostrzezenia WHERE user_id = $1", member.id)
        liczba = result["liczba"] if result else 0
        liczba += 1

        await conn.execute(
            "INSERT INTO ostrzezenia (user_id, liczba) VALUES ($1, $2) ON CONFLICT (user_id) DO UPDATE SET liczba = $2",
            member.id, liczba
        )

        status = "ban" if liczba >= 4 else f"{liczba}/3"

        await log_to_discord(f"üö´ {ctx.author.mention} da≈Ç `bancustom` dla {member.mention} ‚Äì teraz ma: **{status}**")

    await odswiez_panel()

        
@bot.command(name="usunbana")
@commands.has_permissions(administrator=True)
async def usunbana(ctx, member: discord.Member):
    try:
        await ctx.message.delete(delay=5)
    except discord.Forbidden:
        pass

    async with db_pool.acquire() as conn:
        await conn.execute("DELETE FROM ostrzezenia WHERE user_id = $1", member.id)

    await log_to_discord(f"‚úÖ {ctx.author.mention} usunƒÖ≈Ç ostrze≈ºenia dla {member.mention}")
    await odswiez_panel()






bot.run(TOKEN)
